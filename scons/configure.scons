# vim: set ft=python:
import sys
import subprocess
import shlex
import string
import pickle
import os.path
import os

import imp
Import("env", "color_env", "SCONS_ROOT")

cwd = os.getcwd()
os.chdir(os.path.realpath(os.path.join(SCONS_ROOT, "..", "buildutils")))
(f, path, desc) = imp.find_module("version", ["."])
os.chdir(cwd)

version = imp.load_module("version", f, path, desc)

def check_python(conf, major):
    code ="import distutils;"+\
          "import distutils.sysconfig as sysconfig;"+\
          "import pickle;"+\
          "LDVERSION = sysconfig.get_config_var('LDVERSION');"+\
          "VERSION = sysconfig.get_config_var('VERSION');"+\
          "VERSION = LDVERSION if LDVERSION else VERSION;"+\
          "obj = {'PYTHON${MAJOR}_VERSION': sysconfig.get_python_version(),"+\
                 "'PYTHON${MAJOR}_INCPATH': sysconfig.get_python_inc(),"+\
                 "'PYTHON${MAJOR}_LIBPATH': sysconfig.get_config_var('LIBDEST'),"+\
                 "'PYTHON${MAJOR}_LIB': 'python' + VERSION};"+\
          "print(obj);"
    tmpl = string.Template(code)
    code = tmpl.substitute({"MAJOR": major})
    conf.Message("Checking for python%d" % major)
    command = "python%d -c \"%s\"" % (major, code)
    args = shlex.split(command)
    try:
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        p.wait()
    except OSError:
        conf.Result("no")
        return False
    if p.returncode:
        print >> sys.stderr, p.stderr.read()
        conf.Result("no")
    _str = p.stdout.read().strip()
    #print ""
    #print _str

    #pyconf = pickle.loads(_str.strip())
    pyconf = eval(_str)
    for k,v in pyconf.iteritems():
        conf.env[k] = v
    conf.env["python%d_found" % major] = True
    conf.Result("yes")
    return True

LIBS_NEEDED = ["libxml2", "expat"]
PROJECT_NAME = "libcomps"

#for x in [INSTALL_LIB_PATH, INSTALL_LIB32_PATH, INSTALL_LIB64_PATH,
#          INSTALL_INC_PATH, INSTALL_BIN_PATH, INSTALL_SHARE_PATH]:
#    if not Dir(x).exists():
#        Execute(Mkdir(x))

env["PROJECT_NAME"] = PROJECT_NAME
env["LIBCOMPS_BUILD"] = "libcomps-build"
env["LIBPYCOMPS2_BUILD"] = "libpycomps2-build"
env["LIBPYCOMPS3_BUILD"] = "libpycomps3-build"
env["LIBCOMPS_DOCS_BUILD"] = "libcomps-doc-build"
env["LIBPYCOMPS_DOCS_BUILD"] = "libpycomps-doc-build"
env["LIBCOMPS_TESTS"] = "libcomps-tests"
env["LIBPYCOMPS_TESTS"] = "libpycomps-tests"

cache = CacheDir('./cache/')
Decider('MD5')

opts = Variables('%s.conf' % PROJECT_NAME)
opts.Add(PathVariable('PREFIX', 'Directory to install under',
                      '/usr', PathVariable.PathIsDirCreate))
opts.Add(PathVariable('LIBDIR', 'Directory to install library under',
                      '/usr/lib', PathVariable.PathIsDirCreate))
opts.Add(PathVariable('INCDIR', 'Directory to install header files under',
                      '/usr/include', PathVariable.PathIsDirCreate))
opts.Add(PathVariable('SHAREDIR', 'Directory to install data files under',
                      '/usr/share', PathVariable.PathIsDirCreate))

INSTALL_BIN_PATH = "$PREFIX/bin"
if "LIBDIR" in opts.args:
    INSTALL_LIB_PATH = "$LIBDIR"
    INSTALL_LIB32_PATH = "$LIBDIR"
    INSTALL_LIB64_PATH = "$LIBDIR"
else:
    INSTALL_LIB_PATH = "$PREFIX/lib"
    INSTALL_LIB32_PATH = "$PREFIX/lib64"
    INSTALL_LIB64_PATH = "$PREFIX/lib32"

if "INCDIR" in opts.args:
    INSTALL_INC_PATH = "$INCDIR"
else:
    INSTALL_INC_PATH = "$PREFIX/include"

if "SHAREDIR" in opts.args:
    INSTALL_SHARE_PATH = "$SHAREDIR"
else:
    INSTALL_SHARE_PATH = "$PREFIX/share"

if "PYTHON2_SITE" in opts.args:
    PYTHON2_SITE = "$PYTHON2_SITE"
else:
    PYTHON2_SITE = None

if "PYTHON3_SITE" in opts.args:
    PYTHON3_SITE = "$PYTHON3_SITE"
else:
    PYTHON3_SITE = None

opts.Update(env)
opts.Save("%s.conf" % PROJECT_NAME, env)

DISTCLEAN = ["cache", "%s.conf" % PROJECT_NAME, ".sconsign.dblite",
                                                  ".sconf_temp"]

#env.Alias("distclean", DISTCLEAN)
env.Clean("distclean", DISTCLEAN)

version = version.version_load(os.path.realpath(os.path.join(SCONS_ROOT,
                                                             "..",
                                                             "version.cfg")))
#f = open(os.path.join(SCONS_ROOT, "../version.json"))
#version = json.load(f)
#f.close()
#for k,v in version.iteritems():
#    env[k] = v
env["libcomps_VERSION_MAJOR"] = version["MAJOR"]
env["libcomps_VERSION_MINOR"] = version["MINOR"]
env["libcomps_VERSION_PATCH"] = version["PATCH"]
env["libcomps_RELEASE"] = version["RELEASE"]

conf = Configure(env, custom_tests={"check_python": check_python})
if not conf.check_python(2):
    conf.env["python2_found"] = False
else:
    conf.env["python2_found"] = True
if not conf.check_python(3):
    conf.env["python3_found"] = False
else:
    conf.env["python3_found"] = True
conf.check_python(4)

#print dir(conf)

if not env.GetOption('clean'):
    err = 0
    if not conf.CheckCXX():
        print('!! Your compiler and/or environment is not correctly configured.')
        err = 1
    for x in LIBS_NEEDED:
        if not conf.CheckLib(x):
            print >> sys.stderr ,"You need %s to compile %s" % (x, PROJECT_NAME)
            err = 1
    if err:
       Exit(1)

    env = conf.Finish()

Export("PROJECT_NAME", "INSTALL_LIB_PATH", "INSTALL_LIB32_PATH",
       "INSTALL_LIB64_PATH", "INSTALL_INC_PATH", "INSTALL_BIN_PATH",
       "INSTALL_SHARE_PATH")
